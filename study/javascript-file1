简单数据类型和复杂数据类型 
我们js分为两大数据类型: 第一是简单数据类型, 第二是复杂数据类型
简单数据类型分为五大类型: string, number, boolean, undefined, unll
简单数据类型中最特殊的为 unll / 返回的是一个空的对象
unll的使用情况: 如果有一个变量以后打算存储为对象,没想好写什么,这个时候就写为 null
引用数据类型,在存储时变量中存储的仅仅是地址(引用),因此叫做引用数据类型
只要是通过new关键字创建的对象(系统对象,自定义对象),如 Object, Array, Date等
我们学习过的 Object, Array, 都是复杂数据类型,这两种数据类型它们存储关系是不一样的
堆和栈空间分配区别:
简单数据类型都是放到栈里面的 
栈(操作系统): 由操作系统自动分配释放存放函数的参数值,局部变量的值等
值类型变量的数据直接存放在变量(栈空间)中
简单数据类型到底是怎么存储的呐? 比如说我们声明一个变量var age = 10;它是这么来存放的,我们内存分为栈和堆,在我们的简单数据类型中你声明一个变量,首先有一个var age = 18,有一个变量名字叫做 age , 那么这个18是放在哪里的呐? 这个18它在栈里面开辟了一个空间然后把18存储到这里的,然后让我们这个变量名指向这个空间就行可以啦,如果在创建一个简单数据类型,都是往这里去放的,所以说简单数据类型放到栈里面,注意,在栈里面直接存放的是值,这就是我们的简单数据类型它的存储方法
复杂数据类型是存放到堆里面的 复杂数据类型又叫做引用类型
复杂数据类型到底是怎么存储的呐? 比如我们有一个数组 var arr = [1, 2, 3]; 我们知道数组属于复杂数据类型,它是怎么存储的呐,首先数组也要存储到变量里面去,变量是放到我们栈里面的,首先它在我们栈里面开辟了一个空间,然后我这个变量的名字指向了这个空间,但是这个空间里面存放的并不是里面数组的值而是存储的是地址(十六进制的 0x11acc),这个地址又指向我们堆里面,也就是说最终这个数组中的[1, 2, 3]是存放到堆里面去的,在堆里面开辟一个空间,那么这个空间里面存放了三个值,第一个是: 1; 第二个是:2; 第三是:3;复杂数据类型是这么来放的,这个数据是存放到堆里面的,那么怎么找到这个堆呐?首先arr先去通过栈里的地址然后通过地址又找到了我堆里面的数据,它们是这么一个存储关系,复杂数据类型首先在栈里面存放地址用十六进制表示, 然后这个地址指向堆里面的过程,先到栈里面去找地址,找到地址之后然后在指向这个数据就可以啦,真正的对象实例是存放到堆空间里面的
堆(操作系统): 存储复杂类型(对象),一般由我们分配释放,若不回收,由垃圾回收机构回收
注意: javascript中没有堆栈的概念,通过堆栈的方式,可以让大家更容易理解代码的一些执行方式,便于将来学习
函数的形参也可以看做是一个变量,当我们把引用类型变量传给形参时,其实是把变量在栈空间里保存的堆地址复制给了形参,形参和实参其实保存的事同一个堆地址,所以操作的事同一个对象

函数中arguments的使用
我们的函数是有参数的分为实参和形参,当我们不确定有多少个参数传递的时候,就可以用arguments来获取,在js中,arguments实际上它是当前函数的一个内置对象,所有对象都内置了一个arguments对象,arguments对象中存储了传递的所有实参
很多情况下我们也不知道到底传递几个实参给形参,现在的解决方法就是,既然我不知道你实参传递几个给形参,那个我就只写实参不写形参,我们就可以通过arguments把所有的实参拿过来
arguments展示的形式其实是一个伪数组,因此可以对arguments进行遍历
伪数组: 并不是真正的数组,具有length属性,索引方式存储数据,没有数组的push,pop方法

函数返回值两个注意事项
我们的函数如果有return则返回的是return后面的值,如果函数没有,return 则返回undefined
return具有终止函数的功能,return后面的代码不会被执行,return只能返回一个值

全局变量和局部变量
全局变量: 在全局作用域下的变量 在全局中都可以使用, 在任何地方都可以使用
局部变量: 在局部作用域下的变量 在函数内部的变量就是局部变量, 只能在函数内部使用
局部变量: 函数的形参实际上也是局部变量
注意: 在函数内部没有声明直接赋值的变量也是全局变量
全局变量只有浏览器关闭的时候才会销毁,比较占内存资源
局部变量当我们程序执行完毕就会销毁

作用域链
如果函数中还有一个函数,那么在这个作用域中就又可以诞生一个作用域
根据在内部函数可以访问外部函数变量的这种机制,用链式查找决定哪些数据能被内部函数访问,就称为作用域链,根据就近原则来查找

预解析
js代码是由浏览器中的javascript预解析来执行的,javascript预解析在运行js代码的时候,分为两部分, 第一: 先预解析, 然后在代码执行
预解析: js引擎会把js里面的所有的 var 还有function 提升到当前作用域的最前面
代码执行: 按照代码书写的顺序从上往下执行,从右到左执行
预解析分为: 变量预解析(变量提示) 和 函数预解析(函数提升)
变量提升: 就是把所有的变量声明提升到当前的作用域前面 / 只提升声明, 不提升赋值操作
函数提升: 就是把所有的函数声明提升到当前作用域的最前面 / 只提升声明, 不调用函数

对象
利用对象字面量创建对象 var obj = {...};
调用属性的方法: obj.uname;  / obj['uname'];

变量, 属性, 函数, 方法的区别
变量和属性的相同点: 它们都是用来存储数据的
变量 单独声明并赋值 使用的使用直接写变量名 单独存在
属性 在对象里面的不需要声明 使用的使用必须是 / 对象名.属性的方法
函数和方法的相同点: 都是实现某种功能 / 做某件事情
函数是单独声明并且调用的是 / 函数名()来调用 单独存在
方法是在对象里面,调用的时候 / 对象名.方法(); 必须添加小括号才能调用
变量和函数它们都是单独存在 / 属性和方法是放到我们对象里面
变量和函数直接写就可以,但是属性和方法必须要写在对象里面

利用new Object创建对象 var obj = new Object(); 创建一个空对象

利用构造函数创建对象
为什么需要使用构造函数?
因为我们前面两种创建对象的方式一次只能够创建一个对象,里面很多的属性和方法都是大量相同的, 我们只能够复制
因此我们可以利用函数的方法,重复这些相同的代码,我们就把这个函数称为构造函数
因为这个函数不一样,里面封装的不是普通代码,而是对象
构造函数就是把我们对象里面一些相同的属性和方法抽象出来承装到函数里面
构造函数的名字首字母要大写
构造函数调用的时候必须使用new来创建
构造函数不需要return就可以返回结果 / 返回的是一个Object
我们只要new调用函数函数就创建一个对象
我们的属性和方法前面必须添加this
构造函数和对象区别
对象 是一个具体的事物,是客观存在的
构造函数是泛指的某一大类, 把对象的公共属性和方法抽取出来
new关键字
当构造函数遇到new后,首先它会在我们内存中创建一个空的对象
里面的this就会指向这个空对象,只要你new了对象就要实例化,创建一个实实在在的对象
开始执行构造函数里面的代码,给这个空对象添加属性和方法,当实例对象里面的实参传递给形参的时候,就会在里面完成复制操作, 最后在返回这个对象,所以构造函数不需要return
遍历对象
var obj = { age: 20}
for..in语句用于对数组或者对象的属性进行循环操作
for (变量 in 对象) {..}
for (var k in obj) { console.log(k) } // 变量k输出什么哪? / 输出变量得到的是属性名
for (var k in obj) { console.log(obj[k]) } // 输出obj[k]得到的是属性值, 也能遍历方法

内置对象
js中的对象分为三种: 自定义对象, 内置对象, 浏览器对象
Math对象随机数方法 random()返回一个随机的小数 0 =< x < 1;
公式: Math.floor(Math.random()*(max - min + 1)) + min; 可以封装一个函数来实现

Date日期对象
创建Date实例用来处理日期和时间, Date对象基于1970年1月1日起的毫秒
注意: 只能通过调用Date构造函数来实例化日期对象,必须添加new来实例化使用
var date = new Date(); 调用日期内置对象
如果Date里面没有参数 返回当前系统的当前时间
如果有参数: 常用的方式 '2021-6-18 8:8:8'
date.getFullYear(); // 返回当前日期的年份
date.getMonth(); // 返回当前日期的月份,返回是(0-11)的月份会小一个月在后面 + 1 即可
date.getDate(); // 返回当前日期的几号
date.getDay(); // 返回的前期日期的星期几,返回是(周日0到周六6),周日返回0
date.getHours(); // 返回当前日期的小时数
date.getMinutes(); // 返回当前日期的分钟
date.getSeconds(); // 返回当前日期的秒数

var arr = ['星期日', '星期一','星期二', '星期三', '星期四','星期五', '星期六'];封装一个数组
getDay返回一个三,我们可以通过三这个索引号取出来,格式中添加的不是day / 而是arr[day]

获取Date总的毫秒数 不是当前时间的毫秒数,而是距离1970年1月1号过了多少毫秒
通过 valueOf() 和getTime() 获取
倒计时核心算法: 用户输入时间总的毫秒数减去现在时间的总的毫秒数,得到的就是剩余时间
转换公式: d = parseInt(总秒数/60/60/24); // 计算出天数
转换公式: h = parseInt(总秒数/60/60%24); // 计算出小时
转换公式: m = parseInt(总秒数/60%60); // 计算出分数
转换公式: s = parseInt(总秒数%60); // 计算当前秒数

学习数组内置对象
var arr = new Array(1, 2, 3, 4, 5); 利用new Array()构造函数什么数组,存储了[1, 2, 3, 4, 5]
检查是否为数组的方法: instanceof 运算符可以用来检测是否为数组 / 返回布尔值
检查是否为数组的方法语法糖:  Array.isArray(参数);是一个H5新增方法 / 返回布尔值

添加数组方式: push()
push() 是可以给数组追加新的元素
push()在我们数组的末尾,添加一个或者多个数组元素
push() 参数直接写 数组元素就可以了
push() 完毕之后返回的结果是新数组的长度, 原数组也会发生改变

添加数组方式: unshift()
unshift()在我们数组的末尾,添加一个或者多个数组元素

删除数组方式: pop()
pop()可以删除数组中最后一个元素
pop()的返回值是被删除的那个元素

删除数组方式: shift()
它可以删除数组的第一个元素

获取数组元素索引方法: indexOf()
返回数组元素索引号方法 indexOf(数组元素) 作用就是返回数组元素的索引号
idnexOf();从前面开始查找
它只返回第一个满足条件的元素,它如果在数组中找不到这个元素,就会返回 -1

获取数组元素索引方法: lastIndexOf()
返回数组元素索引号方法 indexOf(数组元素) 作用就是返回数组元素的索引号
lastIndexOf();从后面开始查找
它只返回第一个满足条件的元素,它如果在数组中找不到这个元素,就会返回 -1

 6月21日 周一
window.onload是窗口加载事件,当文档内容完全加载完成会触发该事件,就调用处理函数
DOMContentLoaded事件触发时,仅当DOM加载完成,不包括样式表,图片,flash等等
window.onresize是调整窗口大小加载事件,当触发时就会调用的处理函数
setTimeout()方法用于设置一个定时器,该定时器到期后执行调用函数
为什么setTimeout称为回调函数callback(),因为普通函数时按照代码顺序直接调用,而这个函数,需要的是等待时间,时间到了才去调用这个函数,因此称为回调函数,
学习同步任务和异步任务
同步任务都在主线上执行,形成一个执行栈
异步任务: js的异步任务是通过回调函数来实现的
常见的异步任务: 普通事件,资源加载(load),定时器,包括,setTimeout和setInterval等
异步任务(消息队列): 就是回调函数

for of 循环遍历
for (let i of star ) { ... }; 使用for of遍历是可以直接得到属性值的(value)
for of 可以遍历map