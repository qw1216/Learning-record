在面向对象中没有理解到什么是面向过程以及什么是面向对象如何使用
es6中的类和对象: 
面向对象特点: 抽取(对象)对象共用的属性和方法组织(封装)成为一个类(模版)
此时这个类(模版)中有这写对象共用的属性和行为,是泛指的某一大类
我们可以对这个类进行实例化,通过这个类不断产生新的对象出来,获取类的对象
面向对象考虑的是有哪些对象,按照面向对象的思维特点,不断创建对象,使用对象

在js中,对象是一组无序的相关属性和方法的集合,所有事物都是对象,字符串,数组,函数,数值
对象是由属性和方法组成的, 属性: 事物的特征在对象中用属性来表示, 例如年龄多少,性别
对象中的方法: 就是事物的行为.在对象中用方法来表示: 例如可以唱歌,就是可以做什么事情

es6新增class: 只要使用class关键字声明的它就是一个类,之后以这个类来实例化对象
calss 类抽象类对象的公共部分,它是泛指的一大类(class)
对象是特指某一个,是通过类(class)实例化一个具体的对象
1. 创建类 class Star { }  / 2. 利用类创建对象 new Star();  / 必须使new来创建 
在类里面非常重要的函数 constructor() 构造函数
constructor()方法是类的构造函数,(用于传递参数,返回实例对象),通过new命令生成对象实例时,自动调用该方法,如果没显示定义,类内部会自动给我们创建一个constructor(),这样就可以不使用return来返回结果了,这要new了生成实例时,就会自动调用
在es6中,所有类里的函数都可以不用加function
在es6中,所有的函数不需要添加function
在constructor()函数里面的this指向的是我创建的实例
当我们在调用的时候一定要注意,一定要加new来调用
在calss类中必须有constructor()函数,如果不写,内部会自动生成
在类中添加共有方法: 只需要把方法或函数直接写到类里就行

类的继承: 子类是可以继承父类的一些属性和方法的
类的继承: 子类使用extends,既可以继承父类的所有属性和方法 son extends father
super()关键字: 用于访问调用对象父类上的函数,可以调用父类构造函数,也能调用普通函数 
如果在子类使用super(),即子类可以使用父类的constructor()和普通函数
super()关键字也可以调用父类的普通函数
在继承中,如果实例化子类输入一个方法,先看子类有没有这个方法,有就先执行子类的方法
在继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就指向父类的方法
在继承中,如果子类和父类同时都具有方法,遵循的原则是: 就近原则
子类可以继承父类的一些方法,同时子类还可以扩展自己独有的方法
在类里面要求: 必须先有了,super调用完之后,才能使用子类中的this
super 必须在子类this之前调用,先有super才能对子类的this做操作

类和对象的注意点: 在es6中类没有变量提示,所以必须先定义类,才能通过类实例化对象
类里面共有的属性和方法一定要添加this使用
类里面的this指向问题: constructor里面的this指向的是 创建的实例对象
已经记住的单词: constructor..extends..super,这部分基本能理解

晚上八点开始复习Es6
类就是对象的模版,对象就是类的实例
new了一下构造函数会执行四件事情:
第一: 首先会创建一个空的对象,然后第二步让里面的this会指向这个空对象
第三: 就把里面的属性和方法进行赋值操作, 第四,就会返回我们创建的实例对象
所以在构造函数中不需要return, 只要new了就可以把实例对象返回,赋值给新对象

面向对象主要思路: 先把对象的公共部分抽取出来,创建一个类,然后用类生成实例
构造函数中的属性和方法我们称为成员,成员可以添加,成员可以分为两大类:
第一大类: 我们称为实例成员; 第二大类: 我们称为静态成员
实例成员就是构造函数内部通过this添加的成员,构造函数中的 uname age 就是实例成员
实例成员只能通过实例化的对象来访问
第二大类:静态成员: 在构造函数本身上添加的成员 Star.sex 就是静态成员
静态成员只能通过构造函数来访问,不能通过对象实例来访问

构造函数方法很好用,但是存在浪费内存的问题
当我们在创建一个对象的时候,方法就是一个函数,函数属于复杂数据类型,当我们在创建一个新的对象的时候,它会单独的开辟一个内存空间来存放复杂数据类型,如果我们创建两个实例对象,系统就会新开辟两个新的空间来存放,来存放同一个函数,所以构造函数存在浪费内存

我们希望所有的对象使用同一个函数,这样就比较节省内存,那么我们需要怎样做呐?
原型对象: prototype: 有了prototype构造函数通过原型分配的函数是所有对象 (共享的)
每一个构造函数都有一个prototype属性,prototype指向另一个对象,这个prototype就是一个对象,这个对象的所有属性和方法,都会被构造函数所拥有
可以把一些不变的方法,直接定义在prototype对象上,这样所有对象的实例就可以共享方法
star.prototype.sing = fucntion () {.......} 把共有的方法放在这个原型对象上,现在不论常见多少个实例对象,它们不会在开辟空间来存放,而是到这个原型对象上面去找,这样就实现共享

 原型是什么? (原型是prototype原型对象,每一个对象都有prototype原型)
原型的作用是什么? (就是共享相同的方法,节约内存)
一般情况下,我们的公共属性定义到构造函数里面
公共的方法要放到原型对象prototype身上,这样就实现了方法的共享,它不会开辟新的内存

三点钟开始复习es6
为什么方法定义到Star构造函数的原型对象上,为什么我利用new创建的对象,可以使用这个方法,在我用new创建的这个对象上也没哟这个方法啊,什么他能够使用这个方法呐?
对象原型__proto__: 对象都会有一个属性__proto__指向构造函数的prototype原型对象,之所以我们对象可以使用构造函数prototype原型对象的属性和方法,就是因为对象有__proto__原型的存在
__proto__里面存的是一个object对象,而这个__proto__指向的就是protype原型对象,虽然对象身上没有方法,但是我这个对象里面有一个__proto__它指向的是这个原型对象prototype,因为原型对象身上有这个方法,所以我这个对象,就可以拿来使用, 在对象对象身上系统自己添加一个__proto__它指向我们构造函数的原型对象prototype,每一个对象身上都有一个__proto__属性,它指向了我们构造函数的原型对象prototype,所以我们就可以使用这个原型对象上面的这个方法, __proto__对象原型和原型对象prototype是等价的
方法的查找规则: 首先先看kfbk对象身上是否是方法,如果有就执行这个对象上的方法,如果没用这个方法,因为有__proto__的存在,就去构造函数原型对象prototype身上去找这个方法
首先我有一个Star构造函数,然后每一个构造函数都有一个原型对象叫做prototype,首先我把方法放到这个Star.原型对象prototype里面,然后我们利用Star构造函数创建了一个对象,叫做kfbk实例对象,虽然这个kfbk实例对象身上没有方法,但是这个kfbk实例对象身上有一个叫作__proto__的对象原型,这个__proto__对象原型,指向的就是我们Star构造函数的原型对象,__proto__指向了构造函数的原型对象prototype,创建的实例对象kfbk就去原型对象prototype查找,有没有方法,如果有,创建的实例对象kfbk就可以使用这个方法,所以我们创建的实例对象可以使用Star构造函数原型对象prototype里面的属性和方法,__proto__它只是内部指向原型对象prototype的一条线路让它指向了原型对象prototype
constructor 构造函数 : 原型对象(__proto__)和构造函数原型对象(prototype)里面都有一个属性constructor属性,constructor我们称为构造函数,因为它指回构造函数本身,
很多情况下我们需要手动的利用constructor 这个属性指回 原来的构造函数
如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回回来的构造函数



原型链:
构造函数, 实例对象, 原型对象三者之间的关系: 首先我们有一个Star构造函数,我们知道每一个构造函数里面都会有一个原型对象,是通过构造函数的prototype(Star.prototype)指向这个原型对象(Star原型对象prototype),同样在原型对象里面也有一个属性constructor,它又指回了这个Star构造函数这是它们之间的关系,我们知道可以通过构造函数来创建一个实例对象只要我new了构造函数就可以创建实例对象,所以我们构造函数又可以指向这个对象实例,我们又知道在这个对象实例中有一个原型叫做__proto__,它指向的是这个Star原型对象prototype,当然实例对象也有一个constructor,它也可以指回我们的构造函数,但是kfbk.__proto__它指向的是原型对象,指向它之后,原型对象里面有一个constructor,它就可以指回构造函数,所以实例对象是靠通过原型对象指回构造函数的,Star原型对象prototype它也是一个对象,只要是对象就有__porto__原型的存在,此时这个Star原型对象prototype.__proto__指向的是谁呐,原来Star原型对象里面也有一个__proto__,它指向的是我们大写的Object原型对象prototype,(Object.prototype),只要是原型 __proto__,它指向的都是原型对象prototype,接着大写的Object里面的原型对象是由谁创建出来的呐?毫无疑问是通过大写的: Object构造函数创建出来的,那么Object构造函数的Object.protitype就指向Object原型对象prototype,同样道理在这个Object原型对象里面还有一个constructor(Object原型对象.constructor)在指回这个Object构造函数,那么我们Object原型对象prototype它里面的__proto__又指向的是谁呐?Object原型对象的__proto__指向的是为 ( null )这里就到最顶层, / 我们kfbk对象实例里面有一个__proto__原型,它指向的是我们创建的构造函数Star原型对象prototype,那Star原型对象prototype也是一个对象,它里面也有一个__proto__,那么这个原型它指向的是Object原型对象prototype,那么Object原型对象也是一个对象,里面也有一个__proto__,它指向的是null,我们发现里面有许许多多的原型,它们组合成了一条链,所以我们称为原型链,有了这个原型链后面我们在访问对象实例的时候就提供了一条线路,我们先看对象实例里面有没有成员,如果没有就到Star原型对象看看有没有这个成员,如果还没有,就在往一层去找,看看Object原型对象上有没有,如果在没有往上就返回为null / 总结: 只要是对象它里面都有一个原型__proto__,这个原型指向的是原型对象prototype,我们先看kfbk对象实例它里面的__proto__指向的是Star原型对象prototype,那这个Star原型对象prototype也有一个__proto__,它指向的是我们Object的原型对象,那么Object原型对象里面也有一个__proto__,它指向的结果为 null;

按道理:constructor指向的是我到底是利用哪一个构造函数创建出来的,现在我把这个原型对象来了一个赋值操作,发现consrtuctor并没有指回我们原来的构造函数,而是指向了Object对象,Star.prototype是一个对象,如果采取是点的形式,那就是在这个对象上去添加新的方法,但是我让Star.prototype等于了一个对象,也就是说利用后面的对象把原先的Star.prototype里面的对象给全部覆盖了,覆盖过后,我们的Star.prototype里面就没有constructor这个属性了,也就是说,它把constructor给覆盖掉了

js的成员查找机制(规则)
当访问一个对象的属性(包括方法)时,首先查找这个对象自身有没有该属性
如果没有就查找它的原型(也就是__proto__指向的prototype原型对象)
如果还没有就查找原型对象的原型(Object的原型对象)
依次类推一直找到Object为止(null)
一句话它在查找的时候是按照我们这种原型链的机制去查找的
如果实例对象已经有这个成员了,然后Star原型对象上也有这个成员,它会遵循就近原则执行实例对象上的成员
在Object.prototype原型对象上有一个方法叫做: toString();但是在实例对象上和Star.prototype原型对象上是没有这个方法的,虽然这两个上面没有这个方法,但是我Object.prototype上面有这个方法,根据原型链的查找机制,我实例对象就能够使用这个toString()这个方法

原型对象中this的指向问题:
this指向原则: this到底指向谁只有你调用这个函数的时候才能确定
thsi指向原则: 一般情况下this指向的是我们的调用者
构造函数内部的this指向的是: 对象实例, 是我new的那个构造函数
构造函数原型对象prototype的this指向的是: 对象实例, 是我new的那个构造函数

扩展内置对象
可以通过原型对象,对原来的内置对象进行扩展自定义的方法,比如给数组新增自定义求偶数
Array.prototype.sum = function() {.....} 追加数组求和

继承
Es6之前并没有给我们提供extends继承,我们通过构造函数+原型对象实现继承,组合继承
call()这个方法可以调用函数,并且可以修改函数运行时的this的指向问题
fun.call(thisArg, arr1, arr2)里面有三个参数
第一个参数,thisArg: 当前调用函数this的指向对象,可以让this指向另一个对象
第二里面的arr1, arr2是传递的其他参数
call()方法可以调用函数 / call就是来呼叫这个函数,来调用这个函数
call()可以改变这个函数this的指向 / fun.call(obj)这样就把这个函数的this指向了对象
fun.call(thisArg, arr1, arr2);后面两个参数,当成函数的实参来看,它会传递给上面函数的形参

借用构造函数继承父类型属性
核心原理: 通过call()把父类型的this指向子类的this,这样就可以实现子类继承父类的属性
学习了利用原型对象继承方法: 
学习了利用原型对象继承方法有一个坑: 不要直接把父原型对象赋值给子原型对象,这样赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起来变化

类的本质
class本质还是function函数
类的本质其实是一个函数,我们也可以简单认定为类就是构造函数的另一种写法
构造函数都有的特点:
构造函数有原型对象prototype
构造函数原型对象prototype里面有constructor 指向构造函数本身
构造函数可以通过原型对象添加方法
构造函数创建的实例对象有__proto__原型指向 构造函数的原型对象

Es5新增方法
数组方法 / 字符串方法 / 对象方法
数组方法: forEach(currentValue, index, arr)
forEach()里面有一个回调函数,分别有三个参数,第一参数是每一个数组元素,第二个参数是它的一个索引号,第三个参数就是数组本身
数组方法: filter(currentValue, index, arr)
filter()它也可以来迭代(遍历)这个数组,filter()方法创建一个新的数组,新数组中的元素是通过检查指定数组中是否有符合条件的所有元素,主要用于筛选数组,注意:它直接返回一个新数组
filter()里面有一个回调函数,分别有三个参数,第一参数是每一个数组元素,第二个参数是它的一个索引号,第三个参数就是数组本身, 里面必须使用return来返回最后的结果,用于筛选数组,只要满足条件就能够拿到,只要它返回的是一个新数组,所以他不会影响原来的数组,我们可以声明一个变量把这个新数组接受过来
数组方法: some(currentValue, index, arr)
some()方法用于检测数组中的元素是否满足指定条件,查找数组中是否有满足条件的元素
注意: 它返回一个布尔值,如果查找到这个元素,就返回true,如果查找不到就返回false
注意: 如果找到第一个满足条件的元素,则终止循环,不再继续查找
some()里面有一个回调函数,里面必须使用return来返回最后的结果

filter: 也是查找满足条件的元素 返回的是一个数组 而且是把所有满足条件的元素返回
some: 也是查找满足条件的元素是否存在 返回的是一个布尔值 如果查找多第一个满足条件的就终止循环

some和forEach区别
在some里面遇到 return true; 就会终止遍历迭代,效率跟高
foforEach会把所有的都遍历完,而我们的some如果遇到return true;他就会不在遍历终止
如果我们 return true; 说明我们找到了元素我们就不在遍历,如果return flase; 说明没有找到

trim方法去除字符串两侧空格
trim()去除字符长两侧空格,返回一个新字符,只不过需要一个变量来接受: var str = str.trim();
trim()并不能去除中间的空格只能够去除两边的空格 if (input,value.trim() === '' ); 这样写系统会更严谨一些

Object.defineProperty()方法
Object.defineProperty() 定义新属性或者修改原有的属性
以前的方法是通过: Obj.num = 10; 添加新属性
以前的方法是通过: Obj.name = '卡夫不卡'; 修改里面的属性的
Object.defineProperty(obj, prop, descriptor),里面三个参数: 第一个叫做 object你要给哪一个对象修改它的属性呐,第二个是prop(属性的意思),就是你要修改的是哪一个属性,第三个属性是,目标属性所拥有的特性
Object.defineProperty(Obj, 'num', {value: 1000}) 这样写是在原先的对象上添加一个叫做num的属性,它的值是 1000; 注意: 它的第三个参数必须是对象形式的写
如果该对象已经有了这个属性值的时候,就是相当于是修改了原先的值,如果没有的话就是添加,如果有的话就是修改
如果第三个参数是: writable: flase, 则表示该属性是不可以被修改的如果writable为true,就表示是能够被修改的
如果第三个参数是: enumerable: false; 则表示如果你在遍历的时候,你是拿不到这个属性的
如果第三那参数是: configurable; 则表示目标属性是可以被删除是否可以再次修改特性
如果第三个参数是: configurable: flase; 表示不允许目标属性被删除或者可以再次修改特性

函数的定义方式
可以通过函数声明方式function 关键字(命名函数)
可以利用函数表达式(匿名函数)
通过new Function() 用构造函数定义函数 var fun = new Function(参数1, 参数2, 函数体);
Function里面参数必须都是字符串格式
我们所有的函数实际上都是我们这个 Function函数的一个实例(对象),因为我们可以通过new Function创建函数的
我们的函数也是属于对象的
instanceof 用于检测前者是不是属于后者 / 返回一个布尔值
我们所有的函数都是通过大写的Function创建出来的,我们可以通过new Function创建出函数实例对象,我们实例对象肯定有一个__proto__原型,它指向的是大写Function里面的原型对象 prototype,同时我们大写的Function构造函数里面也有一个,Function.prtotype原型对象,指向我们这个Function原型对象protype, 同时大写的Function原型对象里面肯定也有一个constructor在指回我们这个,大写的Function构造函数,这是它们之间的三角关系,
我们先看,我们函数实例对象里面有没有__proto__原型对象指向我们Function原型对象prototype呐,那在大写的Function原型对象上是否有constructor指回我们大写的Function构造函数呐,所以函数也是对象

函数的调用方式: 
第一: 普通函数 / 直接 fun();调用 / 或者fn.call()方法调用
第二: 对象的方法函数 / 采取对象.的方式调用 / obj.sayHi()方法调用
第三: 构造函数 / 只需要 new Star(),只要你new了构造函数调用一下它,就会产生实例对象
第四: 绑定事件函数 / btn.onclick = fucntion() { } / 点击了按钮就可以调用这个函数
第五: 定时器函数 / setInterval (function() { }, 1000) / 这个函数是定时器自动1秒调用一次
第六: 立即执行函数 / (function(){ }) (); 立即执行函数,会立即执行是自动调用

函数内部this的指向问题
this的指向一般情况下: 是当我们调用函数的时候确定的,调用方法的不同决定了this的指向不同,一般this的指向是我们的调用者
第一: 普通函数的this指向 / 指向的是window / 调用时是 window.fun();
第二: 对象里面的函数(方法)this的指向 / 指向的是对象 / 调用时时 obj.object
第三: 构造函数里面的this指向 / this指向的是创建的实例对象
第四: 构造函数原型对象的函数this指向是 / this指向的也是创建的实例对象
第五: 绑定事件函数的this / 指向的是函数的调用者,btn这个按钮
第六: 定时器函数里面this的指向 / 定时器里面的this指向的是window
第七: 立即执行函数里面的this的指向 / 立即执行函数this也是指向的window

改变函数内部this的指向
js中为我们专门提供了一些函数方法来帮我们更优雅的处理函数内部的this指向问题
改变函数内部this的指向的方法: 常用的有 / bind() / call() / apply()
call()方法: 第一,它可以调用函数 / 第二,它可以改变函数中this的指向
call()的主要作用可以实现继承
apply()方法调用一个函数,简单理解为调用函数的方式,但是它可以改变函数的this指向
apply()里面三个参数,第一个参数是在函数运行时指定的this值,第二个参数是传递的值,必须包含在数组里面,第三个值返回值就是函数的返回值,因为它就是调用函数
apply也是调用函数,第二它也可以改变函数内部的this指向
但是apply它的参数必须是数组形式的(伪数组),想要传递参数必须以数组的方式来传递
apply的主要应用 比如我们可以利用 apply 借助数学()math内置对象求最大值
求数组中的最大值: var max = Math.max.apply(Math, arr);
bind()方法不会调用函数,但是能改变函数内部this指向,返回由指定的this的原函数拷贝
bind()方法返回的是原函数改变this之后产生的新函数
如果有的函数我们不需要立即调用,但是又想改变这个函数内部this的指向
disabled = true; 禁用

call apply bind 总结
相同点: 都可以改变函数内部的this指向
区别点: call和apply都会调用函数,并且改变函数内部this指向
它们之间的区别点传递的参数不一样,call传递参数arr1,apply传递参数是以数组形式[arr]传递
bind它们的区别,不会调用函数,但是可以改变函数内部this的指向,如果遇到一个函数不需要调用,但是想要改变里面this的指向,就可以使用bind()方法
应用场景: call()经常做继承,让子构造函数继承父构造函数属性的时候可以用call()方法
应用场景: apply()经常跟数组有关系,比如可以借助Math数学对象求最大值最小值
应用场景: bind()不调用函数,但是还想改变this指向,比如改变定时器内部的this指向

严格模式
'use strict' / 下面的js 代码会按照严格模式执行代码
严格模式的规划: 
在正常模式中,如果一个变量没有声明就赋值,默认是全局变量,严格模式下禁用这种用法,变量必须先有var命令声明,然后再使用
delete num; 删除元素; / delete
在严格模式下不能随意的删除已经定义好了得变脸
在严格模式下this指向有一定的问题
以前在全局作用域函数中的this指向的是window对象
在严格模式下它里面的this不再是指向window而是指向undefined
以前构造函数不加new也可以调用,只是当成普通函数来调用,this指向全局对象
在定时器里面的this还是指向的是window
严格模式下函数里面的参数不允许有重名的参数
严格模式下不允许在非函数的代码块内声明函数,比如不允许在if或者for语句中写函数

高阶函数
高阶函数是对其他函数进行操作的函数,它接收函数作为参数或者将函数作为返回值输出
函数是一种数据类型,同样可以作为参数,传递给另一个参数使用,最典型的就是作为回调函数

回调函数
被作为实参传入另一函数，并在该外部函数内被调用，用以来完成某些任务的函数，称为回调函数。

闭包
变量根据作用域的不同可以分为两种: 全局变量和局部变量
在函数内部是可以使用全局变量的
但是在函数外部是不可以使用局部变量
当函数执行完毕,本作用域内的局部变量会销毁
闭包(closure)指有权访问另一个函数作用域中变量的函数,闭包就是一个函数
一个作用域可以访问另外一个函数内部的局部变量(这就是闭包)
闭包: 我们fun 函数作用域 访问了另外一个函数 fn 里面的局部变量num就满足闭包的条件
闭包: 我们fn 外面的作用域可以访问fn 内部的局部变量
闭包的主要作用: 延伸了变量的作用范围

递归
如果一个函数在内部可以调用其本身,那么这个函数就是递归函数
函数内部自己调用自己,这个函数就是递归函数
递归函数的作用和循环效果一样,递归很容易发生死循环(由于递归很容易发生栈溢出),所以递归函数必须要添加退出条件 return,因为它不断调用自己,调着调着就成了死循环了

浅拷贝和深拷贝
浅拷贝只是拷贝一层,更深层次对象级别的只拷贝引用
浅拷贝的时候如果数据是基本数据类型,那么就如果直接赋值一样,会拷贝其本身,如果除了基本数据类型之外还有一层对象,那么对于浅拷贝而言就是能拷贝其引用,对象的改变会反应的拷贝的对象上,但是深拷贝就会拷贝多层,即使嵌套了对象,也会拷贝出来
所谓拷贝,就是赋值,把第一个变量赋值给另一变量,就是把变量的内容进行拷贝,把一个对象的值赋给另一个对象,就是把一个对象拷贝一份
浅拷贝它只能够把地址拷贝给新数据,这个地址指向的还是原来地址里面存储的数据,我们修改了拷贝完之后的数据,结果是会影响到以前的数据的,就是因为浅拷贝把我们这个更深层次的对象地址拷贝给了新数据,它们两个指向的是同一个数据你只要修改其中任何一方的一个数据,原来的数据都是会受到影响的
Es6中新增浅拷贝的语法糖: Object.assign(target..sources)可以实现浅拷贝
浅拷贝: Object.assign(obj);第一个参数是拷贝那个对象,第二个参数是你要拷贝的对象是谁
所谓的浅拷贝只是拷贝一层,更深层次对象级别的只拷贝引用,就好比只能拷贝对象的属性,如果遇到更深层次的数据的话它只是把地址拷贝过去了,如果此时修改了拷贝过去的数据,之前的数据是会跟着一起来变的,浅拷贝只是把地址拷贝给新数据

深拷贝:所谓的深拷贝可以拷贝多层,每一个级别的数据我都是可以拷贝的
在深拷贝中如果遇到嵌套的对象,它会新开辟一个空间,现在所谓的深拷贝它会把新开辟的这个空间重新赋值一份新的空间,然后把拷贝完的这个空间给新数据,这样他们两个互不相干扰的新空间,这样我在修改了我新数据里面的数据,就不会在影响我之前的数据里面的内容了,它只能够是修改拷贝过的数据,修改拷贝过后的数据后,之前数据的内容不会发生改变
比如一个对象中的属性: 它们属于普通数据类型,而在这个对象里面在嵌套一个对象,如果遇到这种对象数据类型,先遍历外面的数据,然后在遍历里面的数据,可以使用函数递归来实现拷贝
我们在进行遍历的时候先看看你是属于简单数据类型还是,对象形式的复杂数据类型,如果是简单数据类型,我们可以直接浅拷贝操作就行,如果是对象形式的那还需要在进行拷贝

结构赋值
变量的结构赋值: Es6允许通过数组或者对象的方式,对一组变量进行赋值,这个被称为结构
数组的结构赋值: var ['a', 'b', 'c'] = [1, 2, 3]; 这就是一个结构赋值
对象的结构赋值: var {name, sex, age} = stae;(这里是对象名),输出直接输出 name

let变量声明以及声明特性
let变量不能重复声明
Es6中拥有块级作用域  全局, 函数, eval
使用let定义的变量存在块级作用域就是代码只能在代码块内有效,出了这个区域就不起效果
块级作用域的存在: if else while for function object 这些都有块级作用域
Es6中是不存在变量提升的
不影响作用域链,在函数内部定义可以访问到函数外部的数据

const声明常量
常量就是值不能够被修改的量,就是常量
声明const一定要赋初始值
一般常量字母使用大写
声明了常量的值是不能被修改的
const也存在块级作用域的问题
对数组和对象的元素修改(引用保存的是内存地址),不算做是对常量的修改,系统是不会报错的
用常量声明的数组我用push()一个元素进去,系统是不会报错的,因为这个常量所指向的地址没有方式改变,所以不会报错

变量的结构赋值
Es6允许按照一定模式从数组和对象中提取值,对变量进行赋值,这样称为结构赋值

Es6-模版字符串
Es6中引入新的声明字符串的方法 `我也是字符串哦`
模版字符串声明的字符串有什么特性? 
第一: 内容中可以直接出现换行符
第二: 它可以直接进行变量的拼接 `${变量名}可以拼接字符串`语法比较固定‘

Es6-对象的简化写法
Es6允许在大括号里面,直接写入变量和函数,作为对象的属性和方法,这样写更简便
方法声明的简化: 在Es6中方法可以不用写function和冒号,只需写小括号,里面穿形参

Es6中箭头函数以及声明特点
Es6中允许使用箭头 (=>) 定义函数
声明一个函数 let fn = (a,b) => {...}, 在小括号里面写形参
箭头函数声明的特性:
第一: this是静态的 this始终是指向函数声明时所在作用域this下的值,它并没有自己的this,箭头函数this时静态的,它始终是指向函数在声明时所在作用域下this指向的值,不论是使用call()去改变this的指向,箭头函数的this的指向是永远不会变的
在全局作用域下声明的箭头函数this永远都是指向window对象,同普通函数一样指向window
箭头函数不能作为构造函数去实例对象的,系统会直接报错
箭头函数中是不能使用arguments变量,虽然虽有函数都有arguments,但是箭头函数除外
关于箭头函数的简写: 
第一: 当形参有且只有一个的时候, 可以省略写小括号
第二: 当代码体只有一行语句的时候, 可以省略写花括号,此时return必须省略,而且语句的执行结果就是函数的返回值
箭头函数的使用场景: 我们箭头函数它本身this是静态的,箭头函数this它是指向它本身在声明时所在 (‘作用域下的this中’),也就是说如果这个箭头函数,他在全局作用域下声明的,箭头函数的this就永远指向window, 如果在点击事件里面声明一个箭头函数,那么这个箭头函数的this就会指向这个点击事件,而且是永远指向,并且不能够使用 call()和apply()改变this指向
箭头函数适合与this 无关的回调,比如定时器,数组方法的回调
箭头函数不适合与this有关的回调, 比如事件回调,对象的方法也不太适合

Es6函数参数的默认值设置
Es6中允许给函数参数赋初始值
function add(a, b, c=10); 当函数传实参的如果有c就使用10,如果实参没有c,也能使用10
形参初始值 具有默认值的参数, 一般位置要靠后

Es6-rest参数
Es6 引入rest参数,用于获取函数的实参,用来替代 arguments

Es6-symbol的介绍和创建
Es6 引入了一种新的原始数据 symbol 表示独一无二的值,它是js语言中第七种数据类型,是一种类似于字符串的类型
symbol 特点:
symbol 的值是唯一的,用来解决命名冲突的问题
symbol 值不能与其他数据进行运算
symbol 定义的对象属性不能使用 for..in 循环遍历,但是可以使用Reflect.ownKeys来获取对象的所有键名
创建symbol
第一: 可以用函数创建: let s = Symbol(); 唯一性我们是不可见的,它内部实现了唯一性
第二: 用函数创建: let s2 = Symbol('卡夫不卡'); 这个字符串是一个描述字符串,方便我们通过描述字符串更好的理解这个值的作用,字面就跟注释差不会,表示出来我这个Symbol是为什么设置的,是干什么的
第三: 使用Symbol.for方法创建: let s3 = Symbol.for(); 此时这个Symbol成了一个对象
不能与其他数据进行运算
symbol的使用场景: 就是给对象添加属性和方法表示独一无二的

undefined 和 unll 的区别
undefined表示是一个变量定义了但是没有赋值,这就是undefined
而null表示的是定义了并且赋值过,只不过值为空而已
什么时候给变量赋值为null?
我有一个对象我现在不知道给它赋什么值,我就可以把它赋值为null,表示初始赋值为null

内存,数据,变量三者的关系
什么是数据?
存储在内存中代表特定信息的事物,就是数据, 本质是 010101...二进制数据
什么是内存?
好比: 内存条通电以后阐述的可存储数据的空间,是临时的,内存产生生产和死亡